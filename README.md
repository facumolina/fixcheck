# fixcheck
FixCheck is a tool for improving patch correctness analysis. Given a target Java patch, it uses static analysis and random testing to generate new inputs to test the patch, and LLMs to generate meaningful assertions for the new inputs. The new tests are executed and those that fail are selected and prioritised according to their likelihood of revealing a defect in the patch.

## Setting up FixCheck

### Requirements

- Java >= 17 (tested with 17)
- Python3 (tested with 3.11.5)

### Local Installation

To install FixCheck, just clone the repository, build the project with gradle and install the python requirements:
```bash  
git clone https://github.com/facumolina/fixcheck
cd fixcheck
./gradlew shadowJar 
pip3 install -r experiments/requirements.txt
pip3 install -r llms/requirements.txt
```
Finally, set up the FixCheck environment variable:
```bash  
export FIXCHECK=path_to_thisrepo
```

### Docker

TBD

## Using FixCheck

### Example

This section contains a simple example analysing a candidate patch from the [DefectRepairing](https://github.com/Ultimanecat/DefectRepairing) benchmark, which contains correct and incorrect patches generated by APR tools. To run FixCheck on any of these patches, we first need to perform the following steps:

1. Download and install [defects4j](https://github.com/rjust/defects4j) (make sure the command defects4j is available)
2. Download the [DefectRepairing](https://github.com/Ultimanecat/DefectRepairing) benchmark

After that, the following variable needs to be set:
```bash  
export DEFECT_REPAIRING_DATASET=<path_to_defectrepairing> 
```
Now that the dependencies are installed, we can use FixCheck to analyse the patches.  Before the actual execution of FixCheck, we need to perform a setup step, that essentially will clone the project corresponding to the patch under analysis, apply the patch and build the project. For instance, to analyse the Patch1, the setup can be performed by running:
```bash  
python3 experiments/setup-defect-repairing.py Patch1
```
> [!IMPORTANT]
> When running the setup script, Java 8 should be configured, as it is required to build Defects4J projects.

From this point, we can now execute FixCheck as follows:
```bash
nohup python3 llms/codellama-7b-instruct.py &  
python3 experiments/run-fixcheck-defect-repairing.py Patch1
```
The first script will setup the `codellama-7b-instruct` language model, and leave it ready to be called by FixCheck. The second script will automatically extract the arguments from the file `experiments/defect-repairing-subjects.csv`, and call FixCheck with the right parameters. For instance, the command used for the Patch1 subject is the following:
```bash  
java -cp build/libs/fixcheck-all-1.0.0.jar:$DEFECT_REPAIRING_DATASET/tmp/Patch1/Chart1b/build:$DEFECT_REPAIRING_DATASET/tmp/Patch1/Chart1b/build-tests org.imdea.fixcheck.FixCheck 
  -tp $DEFECT_REPAIRING_DATASET/tmp/Patch1/Chart1b/build-tests 
  -tc org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests 
  -tm test2947660 
  -ts $DEFECT_REPAIRING_DATASET/tmp/Patch1/Chart1b/tests 
  -i java.lang.String 
  -tf $DEFECT_REPAIRING_DATASET/tmp/Patch1/Chart1b/failing_tests 
  -np 100 
  -ag org.imdea.fixcheck.assertion.CodeLlamaInstruct
```
Other patches from the [DefectRepairing](https://github.com/Ultimanecat/DefectRepairing) benchmark can also be analysed following the same procedure, as they are all configured in the csv file `experiments/defect-repairing-subjects.csv`.

### Analysing Patches from other sources
TBD

### Command-line interface

### Extending FixCheck
TBD

## Contact
TBD



